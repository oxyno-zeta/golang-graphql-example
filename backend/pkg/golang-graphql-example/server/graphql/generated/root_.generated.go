// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/oxyno-zeta/golang-graphql-example/pkg/golang-graphql-example/business/todos/models"
	"github.com/oxyno-zeta/golang-graphql-example/pkg/golang-graphql-example/server/graphql/model"
	"github.com/oxyno-zeta/golang-graphql-example/pkg/golang-graphql-example/server/graphql/utils"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	Todo() TodoResolver
	BooleanFilter() BooleanFilterResolver
	DateFilter() DateFilterResolver
	IntFilter() IntFilterResolver
	StringFilter() StringFilterResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Mutation struct {
		CloseTodo  func(childComplexity int, todoID string) int
		CreateTodo func(childComplexity int, input model.NewTodo) int
		UpdateTodo func(childComplexity int, input *model.UpdateTodo) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Todo  func(childComplexity int, id string) int
		Todos func(childComplexity int, after *string, before *string, first *int, last *int, sort *models.SortOrder, sorts []*models.SortOrder, filter *models.Filter) int
	}

	Todo struct {
		CreatedAt func(childComplexity int, format *utils.DateFormat) int
		Done      func(childComplexity int) int
		ID        func(childComplexity int) int
		Text      func(childComplexity int) int
		UpdatedAt func(childComplexity int, format *utils.DateFormat) int
	}

	TodoConnection struct {
		Edges    func(childComplexity int) int
		PageInfo func(childComplexity int) int
	}

	TodoEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Mutation.closeTodo":
		if e.complexity.Mutation.CloseTodo == nil {
			break
		}

		args, err := ec.field_Mutation_closeTodo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CloseTodo(childComplexity, args["todoId"].(string)), true

	case "Mutation.createTodo":
		if e.complexity.Mutation.CreateTodo == nil {
			break
		}

		args, err := ec.field_Mutation_createTodo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateTodo(childComplexity, args["input"].(model.NewTodo)), true

	case "Mutation.updateTodo":
		if e.complexity.Mutation.UpdateTodo == nil {
			break
		}

		args, err := ec.field_Mutation_updateTodo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateTodo(childComplexity, args["input"].(*model.UpdateTodo)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.todo":
		if e.complexity.Query.Todo == nil {
			break
		}

		args, err := ec.field_Query_todo_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Todo(childComplexity, args["id"].(string)), true

	case "Query.todos":
		if e.complexity.Query.Todos == nil {
			break
		}

		args, err := ec.field_Query_todos_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Todos(childComplexity, args["after"].(*string), args["before"].(*string), args["first"].(*int), args["last"].(*int), args["sort"].(*models.SortOrder), args["sorts"].([]*models.SortOrder), args["filter"].(*models.Filter)), true

	case "Todo.createdAt":
		if e.complexity.Todo.CreatedAt == nil {
			break
		}

		args, err := ec.field_Todo_createdAt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Todo.CreatedAt(childComplexity, args["format"].(*utils.DateFormat)), true

	case "Todo.done":
		if e.complexity.Todo.Done == nil {
			break
		}

		return e.complexity.Todo.Done(childComplexity), true

	case "Todo.id":
		if e.complexity.Todo.ID == nil {
			break
		}

		return e.complexity.Todo.ID(childComplexity), true

	case "Todo.text":
		if e.complexity.Todo.Text == nil {
			break
		}

		return e.complexity.Todo.Text(childComplexity), true

	case "Todo.updatedAt":
		if e.complexity.Todo.UpdatedAt == nil {
			break
		}

		args, err := ec.field_Todo_updatedAt_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Todo.UpdatedAt(childComplexity, args["format"].(*utils.DateFormat)), true

	case "TodoConnection.edges":
		if e.complexity.TodoConnection.Edges == nil {
			break
		}

		return e.complexity.TodoConnection.Edges(childComplexity), true

	case "TodoConnection.pageInfo":
		if e.complexity.TodoConnection.PageInfo == nil {
			break
		}

		return e.complexity.TodoConnection.PageInfo(childComplexity), true

	case "TodoEdge.cursor":
		if e.complexity.TodoEdge.Cursor == nil {
			break
		}

		return e.complexity.TodoEdge.Cursor(childComplexity), true

	case "TodoEdge.node":
		if e.complexity.TodoEdge.Node == nil {
			break
		}

		return e.complexity.TodoEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputBooleanFilter,
		ec.unmarshalInputDateFilter,
		ec.unmarshalInputIntFilter,
		ec.unmarshalInputNewTodo,
		ec.unmarshalInputStringFilter,
		ec.unmarshalInputTodoFilter,
		ec.unmarshalInputTodoSortOrder,
		ec.unmarshalInputUpdateTodo,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../../../../../graphql/schema.graphql", Input: `# GraphQL schema example
#
# https://gqlgen.com/getting-started/

type Query {
  todos(
    """
    Cursor delimiter after you want data (used with first only)

    See here: https://relay.dev/graphql/connections.htm#sec-Forward-pagination-arguments
    """
    after: String
    """
    Cursor delimiter before you want data (used with after only)

    See here: https://relay.dev/graphql/connections.htm#sec-Backward-pagination-arguments
    """
    before: String
    """
    First elements

    See here: https://relay.dev/graphql/connections.htm#sec-Forward-pagination-arguments
    """
    first: Int
    """
    Last elements (used only with before)

    See here: https://relay.dev/graphql/connections.htm#sec-Backward-pagination-arguments
    """
    last: Int
    """
    Sort
    """
    sort: TodoSortOrder @deprecated(reason: "Use sort list instead")
    """
    Sort list
    """
    sorts: [TodoSortOrder]
    """
    Filter
    """
    filter: TodoFilter
  ): TodoConnection
  todo(id: String!): Todo
}

type Mutation {
  createTodo(input: NewTodo!): Todo!
  closeTodo(todoId: ID!): Todo!
  updateTodo(input: UpdateTodo): Todo!
}
`, BuiltIn: false},
	{Name: "../../../../../graphql/todo.graphql", Input: `"""
This represents a Todo object
"""
type Todo {
  id: ID!
  createdAt(format: DateFormat): String!
  updatedAt(format: DateFormat): String!
  text: String!
  done: Boolean!
}

input NewTodo {
  text: String!
}

input UpdateTodo {
  id: ID!
  text: String!
}

type TodoConnection {
  edges: [TodoEdge]
  pageInfo: PageInfo!
}

type TodoEdge {
  cursor: String!
  node: Todo
}

input TodoSortOrder {
  createdAt: SortOrderEnum
  updatedAt: SortOrderEnum
  text: SortOrderEnum
  done: SortOrderEnum
}

input TodoFilter {
  AND: [TodoFilter!]
  OR: [TodoFilter!]
  createdAt: DateFilter
  updatedAt: DateFilter
  text: StringFilter
  done: BooleanFilter
}
`, BuiltIn: false},
	{Name: "../../../../../graphql/utils.graphql", Input: `"""
Pagination information
"""
type PageInfo {
  """
  Has a next page ?
  """
  hasNextPage: Boolean!
  """
  Has a previous page ?
  """
  hasPreviousPage: Boolean!
  """
  Shortcut to first edge cursor in the result chunk
  """
  startCursor: String
  """
  Shortcut to last edge cursor in the result chunk
  """
  endCursor: String
}

"""
Sort for enumeration
"""
enum SortOrderEnum {
  ASC
  DESC
}

"""
String filter structure
"""
input StringFilter {
  """
  Allow to test equality to
  """
  eq: String
  """
  Allow to test non equality to
  """
  notEq: String
  """
  Allow to test if a string contains another string.
  """
  contains: String
  """
  Allow to test if a string isn't containing another string.
  """
  notContains: String
  """
  Allow to test if a string starts with another string.
  """
  startsWith: String
  """
  Allow to test if a string isn't starting with another string.
  """
  notStartsWith: String
  """
  Allow to test if a string ends with another string.
  """
  endsWith: String
  """
  Allow to test if a string isn't ending with another string.
  """
  notEndsWith: String
  """
  Allow to test if value is in array
  """
  in: [String]
  """
  Allow to test if value isn't in array
  """
  notIn: [String]
  """
  Allow to test if value is null
  """
  isNull: Boolean
  """
  Allow to test if value is not null
  """
  isNotNull: Boolean
  """
  Allow case insensitive search.
  """
  caseInsensitive: Boolean
}

"""
Integer filter structure
"""
input IntFilter {
  """
  Allow to test equality to
  """
  eq: Int
  """
  Allow to test non equality to
  """
  notEq: Int
  """
  Allow to test greater or equal than
  """
  gte: Int
  """
  Allow to test not greater or equal than
  """
  notGte: Int
  """
  Allow to test greater than
  """
  gt: Int
  """
  Allow to test not greater than
  """
  notGt: Int
  """
  Allow to test less or equal than
  """
  lte: Int
  """
  Allow to test not less or equal than
  """
  notLte: Int
  """
  Allow to test less than
  """
  lt: Int
  """
  Allow to test not less than
  """
  notLt: Int
  """
  Allow to test if value is in array
  """
  in: [Int]
  """
  Allow to test if value isn't in array
  """
  notIn: [Int]
  """
  Allow to test if value is null
  """
  isNull: Boolean
  """
  Allow to test if value is not null
  """
  isNotNull: Boolean
}

"""
Boolean filter structure
"""
input BooleanFilter {
  """
  Allow to test equality to
  """
  eq: Boolean
  """
  Allow to test non equality to
  """
  notEq: Boolean
}

"""
Date filter structure
"""
input DateFilter {
  """
  Allow to test equality to
  """
  eq: String
  """
  Allow to test non equality to
  """
  notEq: String
  """
  Allow to test greater or equal than
  """
  gte: String
  """
  Allow to test not greater or equal than
  """
  notGte: String
  """
  Allow to test greater than
  """
  gt: String
  """
  Allow to test not greater than
  """
  notGt: String
  """
  Allow to test less or equal than
  """
  lte: String
  """
  Allow to test not less or equal than
  """
  notLte: String
  """
  Allow to test less than
  """
  lt: String
  """
  Allow to test not less than
  """
  notLt: String
  """
  Allow to test if value is in array
  """
  in: [String]
  """
  Allow to test if value isn't in array
  """
  notIn: [String]
  """
  Allow to test if value is null
  """
  isNull: Boolean
  """
  Allow to test if value is not null
  """
  isNotNull: Boolean
}

"""
Date Format enumeration
"""
enum DateFormat {
  """
  RFC3339 format
  """
  RFC3339
  """
  RFC3339 with nanoseconds format
  """
  RFC3339Nano
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
