package gen

import (
	"bytes"
	"fmt"
	"reflect"
	"strings"
	"sync"

	"github.com/dave/jennifer/jen"
	"gorm.io/gorm/schema"
)

const (
	errorPkg                         = "emperror.dev/errors"
	gormVariableNameSuffix           = "GormColumnName"
	jsonKeyNameSuffix                = "JSONKeyName"
	structKeyNameSuffix              = "StructKeyName"
	unsupportedGormColumnErrTemplate = "Err%sUnsupportedGormColumn"
	unsupportedJSONKeyErrTemplate    = "Err%sUnsupportedJSONKey"
	unsupportedStructKeyErrTemplate  = "Err%sUnsupportedStructKeyName"
)

type MainPkg struct {
	GormMap           map[string]string
	JSONMap           map[string]string
	StructKeyNamesMap map[string]string
	ObjectName        string
}

func saveJSONKeys(rType reflect.Type, jsonMap map[string]string) {
	// Loop over object field
	for i := 0; i < rType.NumField(); i++ {
		// Get field
		fieldType := rType.Field(i)
		// Get tag value for field
		jsonTagValue := fieldType.Tag.Get("json")
		// Check if tag isn't set or marked to ignore
		if jsonTagValue == "-" {
			continue
		}

		// Check if it is anonymous
		if fieldType.Anonymous {
			// Need to go deeper
			saveJSONKeys(fieldType.Type, jsonMap)

			continue
		}

		// skip private fields
		if !fieldType.IsExported() {
			continue
		}

		// Check if it is empty
		if jsonTagValue == "" {
			jsonMap[rType.Field(i).Name] = rType.Field(i).Name
		} else {
			// Split over ,
			jsonTagValueSplit := strings.Split(jsonTagValue, ",")
			// Get first value as it is the key name
			jsonMap[rType.Field(i).Name] = jsonTagValueSplit[0]
		}
	}
}

func getPackageData(pkgName string, obj any, disableJSON, disableGorm, disableStructKeyName bool) (*MainPkg, error) {
	// Init gorm map
	gormMap := make(map[string]string)

	if !disableGorm {
		// Manage Gorm
		// Parse object to get schema
		s, err := schema.Parse(obj, &sync.Map{}, schema.NamingStrategy{})
		// Check error
		if err != nil {
			return nil, err
		}

		// Loop over gorm fields
		for _, field := range s.Fields {
			dbName := field.DBName
			// Check if db field is set
			if dbName != "" {
				gormMap[field.Name] = dbName
			}
		}
	}

	// Get reflect type of object
	rType := reflect.TypeOf(obj)

	// Init json map
	jsonMap := make(map[string]string)

	if !disableJSON {
		// Save json keys
		saveJSONKeys(rType, jsonMap)
	}

	structKeyNamesMap := make(map[string]string)

	if !disableStructKeyName {
		saveStructKeyNames(rType, structKeyNamesMap)
	}

	return &MainPkg{
		ObjectName:        rType.Name(),
		GormMap:           gormMap,
		JSONMap:           jsonMap,
		StructKeyNamesMap: structKeyNamesMap,
	}, nil
}

func saveStructKeyNames(rType reflect.Type, structKeyNamesMap map[string]string) {
	// Loop over object field
	for i := 0; i < rType.NumField(); i++ {
		// Get field
		fieldType := rType.Field(i)

		// Check if it is anonymous
		if fieldType.Anonymous {
			// Need to go deeper
			saveStructKeyNames(fieldType.Type, structKeyNamesMap)

			continue
		}

		// skip private fields
		if !fieldType.IsExported() {
			continue
		}

		structKeyNamesMap[rType.Field(i).Name] = rType.Field(i).Name
	}
}

func Generate(pkgName string, obj any, disableJSON, disableGorm, disableStructKeyName bool) (*bytes.Buffer, error) {
	// Create new file
	f := jen.NewFile(pkgName)

	// A comment to mark the file as generated
	f.PackageComment("Code generated by ModelTags, DO NOT EDIT.")

	// Get main package data
	mainPkg, err := getPackageData(pkgName, obj, disableJSON, disableGorm, disableStructKeyName)
	// Check error
	if err != nil {
		return nil, err
	}

	addErrors(f, mainPkg, disableGorm, disableJSON, disableStructKeyName)

	if !disableGorm {
		generateGormVariables(f, mainPkg)
	}

	if !disableJSON {
		generateJSONVariables(f, mainPkg)
	}

	if !disableStructKeyName {
		generateStructKeyVariables(f, mainPkg)
	}

	generateTransformFunctions(f, mainPkg, disableJSON, disableGorm, disableStructKeyName)

	buf := &bytes.Buffer{}

	err = f.Render(buf)
	// Check error
	if err != nil {
		return nil, err
	}

	return buf, nil
}

func addErrors(f *jen.File, mainPkg *MainPkg, disableGorm, disableJSON, disableStructKeyName bool) {
	if !disableGorm {
		f.Commentf(unsupportedGormColumnErrTemplate+" will be thrown when an unsupported Gorm column will be found in transform function.", mainPkg.ObjectName)
		f.Var().
			Id(fmt.Sprintf(unsupportedGormColumnErrTemplate, mainPkg.ObjectName)).
			Op("=").
			Qual(errorPkg, "Sentinel").
			Parens(jen.Lit("unsupported gorm column"))
		f.Line()
	}

	if !disableJSON {
		f.Commentf(unsupportedJSONKeyErrTemplate+" will be thrown when an unsupported JSON key will be found in transform function.", mainPkg.ObjectName)
		f.Var().Id(fmt.Sprintf(unsupportedJSONKeyErrTemplate, mainPkg.ObjectName)).Op("=").Qual(errorPkg, "Sentinel").Parens(jen.Lit("unsupported json key"))
		f.Line()
	}

	if !disableStructKeyName {
		f.Commentf(unsupportedStructKeyErrTemplate+" will be thrown when an unsupported structure key will be found in transform function.", mainPkg.ObjectName)
		f.Var().
			Id(fmt.Sprintf(unsupportedStructKeyErrTemplate, mainPkg.ObjectName)).
			Op("=").
			Qual(errorPkg, "Sentinel").
			Parens(jen.Lit("unsupported struct key"))
		f.Line()
	}
}

func generateGormVariables(f *jen.File, mainPkg *MainPkg) {
	f.Comment("/* Gorm columns Names */")

	list := []jen.Code{}
	for k, v := range mainPkg.GormMap {
		vName := mainPkg.ObjectName + k + gormVariableNameSuffix

		f.Commentf("%s %s Gorm Column Name", mainPkg.ObjectName, k)
		f.Const().Id(vName).Op("=").Lit(v)

		list = append(list, jen.Id(vName))
	}

	f.Var().Id(mainPkg.ObjectName + gormVariableNameSuffix + "List").Op("=").Index().String().Values(list...)
}

func generateJSONVariables(f *jen.File, mainPkg *MainPkg) {
	f.Comment("/* JSON Key Names */")

	list := []jen.Code{}
	for k, v := range mainPkg.JSONMap {
		vName := mainPkg.ObjectName + k + jsonKeyNameSuffix

		f.Commentf("%s %s JSON Key Name", mainPkg.ObjectName, k)
		f.Const().Id(vName).Op("=").Lit(v)

		list = append(list, jen.Id(vName))
	}

	f.Var().Id(mainPkg.ObjectName + jsonKeyNameSuffix + "List").Op("=").Index().String().Values(list...)
}

func generateStructKeyVariables(f *jen.File, mainPkg *MainPkg) {
	f.Comment("/* Struct Key Names */")

	list := []jen.Code{}
	for k, v := range mainPkg.StructKeyNamesMap {
		vName := mainPkg.ObjectName + k + structKeyNameSuffix

		f.Commentf("%s %s Struct Key Name", mainPkg.ObjectName, k)
		f.Const().Id(vName).Op("=").Lit(v)

		list = append(list, jen.Id(vName))
	}

	f.Var().Id(mainPkg.ObjectName + structKeyNameSuffix + "List").Op("=").Index().String().Values(list...)
}

func generateTransformFunctions(f *jen.File, mainPkg *MainPkg, disableJSON, disableGorm, disableStructKeyName bool) {
	if !disableJSON && !disableGorm {
		gormToJsonKeyCases := []jen.Code{}
		jsonToGormKeyCases := []jen.Code{}

		for k := range mainPkg.GormMap {
			gormToJsonKeyCases = append(gormToJsonKeyCases, jen.
				Case(jen.Id(mainPkg.ObjectName+k+gormVariableNameSuffix)).
				Block(
					jen.Return(
						jen.Id(mainPkg.ObjectName+k+jsonKeyNameSuffix),
						jen.Nil(),
					),
				),
			)
		}
		for k := range mainPkg.JSONMap {
			jsonToGormKeyCases = append(jsonToGormKeyCases, jen.
				Case(jen.Id(mainPkg.ObjectName+k+jsonKeyNameSuffix)).
				Block(
					jen.Return(
						jen.Id(mainPkg.ObjectName+k+gormVariableNameSuffix),
						jen.Nil(),
					),
				),
			)
		}

		gormToJsonKeyCases = append(gormToJsonKeyCases, jen.Default().Block(
			jen.Return(
				jen.Lit(""),
				jen.Id("errors").Dot("WithStack").
					Call(jen.Id(
						fmt.Sprintf(unsupportedGormColumnErrTemplate, mainPkg.ObjectName),
					)),
			),
		))

		jsonToGormKeyCases = append(jsonToGormKeyCases, jen.Default().Block(
			jen.Return(
				jen.Lit(""),
				jen.Id("errors").Dot("WithStack").
					Call(jen.Id(
						fmt.Sprintf(unsupportedJSONKeyErrTemplate, mainPkg.ObjectName),
					)),
			),
		))

		f.Commentf("// Transform %s Gorm Column To JSON Key", mainPkg.ObjectName)
		f.Func().Id(fmt.Sprintf("Transform%sGormColumnToJSONKey", mainPkg.ObjectName)).
			Params(jen.Id("gormColumn").String()).Params(jen.String(), jen.Error()).
			Block(jen.Switch(jen.Id("gormColumn")).Block(gormToJsonKeyCases...))

		f.Commentf("// Transform %s JSON Key To Gorm Column", mainPkg.ObjectName)
		f.Func().Id(fmt.Sprintf("Transform%sJSONKeyToGormColumn", mainPkg.ObjectName)).
			Params(jen.Id("jsonKey").String()).Params(jen.String(), jen.Error()).
			Block(jen.Switch(jen.Id("jsonKey")).Block(jsonToGormKeyCases...))

		f.Commentf("Transform %s JSON Key map To Gorm Column map", mainPkg.ObjectName)
		f.Func().Id(fmt.Sprintf("Transform%sJSONKeyMapToGormColumnMap", mainPkg.ObjectName)).
			Params(
				jen.Id("input").Map(jen.String()).Any(),
				jen.Id("ignoreUnsupportedError").Bool(),
			).
			Params(jen.Map(jen.String()).Any(), jen.Error()).
			Block(
				jen.Id("m").Op(":=").Map(jen.String()).Any().Values(),
				jen.Line(),
				jen.For(jen.Id("k").Op(",").Id("v").Op(":=").Range().Id("input").Block(
					jen.Id("r").Op(",").Err().Op(":=").Id(
						fmt.Sprintf("Transform%sJSONKeyToGormColumn", mainPkg.ObjectName),
					).Call(jen.Id("k")),
					jen.If(jen.Err().Op("!=").Nil()).Block(
						jen.If(jen.Id("ignoreUnsupportedError").Op("&&").
							Id("errors").Op(".").Id("Is").Call(
							jen.Err(),
							jen.Id(fmt.Sprintf(unsupportedJSONKeyErrTemplate, mainPkg.ObjectName)),
						)).Block(jen.Continue()),
						jen.Return(jen.Nil(), jen.Err()),
					),
					jen.Id("m").Index(jen.Id("r")).Op("=").Id("v"),
				)),
				jen.Line(),
				jen.Return(jen.Id("m"), jen.Nil()),
			)

		f.Commentf("Transform %s Gorm Column map To JSON Key map", mainPkg.ObjectName)
		f.Func().Id(fmt.Sprintf("Transform%sGormColumnMapToJSONKeyMap", mainPkg.ObjectName)).
			Params(
				jen.Id("input").Map(jen.String()).Any(),
				jen.Id("ignoreUnsupportedError").Bool(),
			).
			Params(jen.Map(jen.String()).Any(), jen.Error()).
			Block(
				jen.Id("m").Op(":=").Map(jen.String()).Any().Values(),
				jen.Line(),
				jen.For(jen.Id("k").Op(",").Id("v").Op(":=").Range().Id("input").Block(
					jen.Id("r").Op(",").Err().Op(":=").Id(
						fmt.Sprintf("Transform%sGormColumnToJSONKey", mainPkg.ObjectName),
					).Call(jen.Id("k")),
					jen.If(jen.Err().Op("!=").Nil()).Block(
						jen.If(jen.Id("ignoreUnsupportedError").Op("&&").
							Id("errors").Op(".").Id("Is").Call(
							jen.Err(),
							jen.Id(fmt.Sprintf(unsupportedGormColumnErrTemplate, mainPkg.ObjectName)),
						)).Block(jen.Continue()),
						jen.Return(jen.Nil(), jen.Err()),
					),
					jen.Id("m").Index(jen.Id("r")).Op("=").Id("v"),
				)),
				jen.Line(),
				jen.Return(jen.Id("m"), jen.Nil()),
			)
	}

	if !disableStructKeyName && !disableGorm {
		gormToStructKeyCases := []jen.Code{}
		structToGormKeyCases := []jen.Code{}

		for k := range mainPkg.GormMap {
			gormToStructKeyCases = append(gormToStructKeyCases, jen.
				Case(jen.Id(mainPkg.ObjectName+k+gormVariableNameSuffix)).
				Block(
					jen.Return(
						jen.Id(mainPkg.ObjectName+k+structKeyNameSuffix),
						jen.Nil(),
					),
				),
			)
		}
		for k := range mainPkg.JSONMap {
			structToGormKeyCases = append(structToGormKeyCases, jen.
				Case(jen.Id(mainPkg.ObjectName+k+structKeyNameSuffix)).
				Block(
					jen.Return(
						jen.Id(mainPkg.ObjectName+k+gormVariableNameSuffix),
						jen.Nil(),
					),
				),
			)
		}

		gormToStructKeyCases = append(gormToStructKeyCases, jen.Default().Block(
			jen.Return(
				jen.Lit(""),
				jen.Id("errors").Dot("WithStack").
					Call(jen.Id(
						fmt.Sprintf(unsupportedGormColumnErrTemplate, mainPkg.ObjectName),
					)),
			),
		))

		structToGormKeyCases = append(structToGormKeyCases, jen.Default().Block(
			jen.Return(
				jen.Lit(""),
				jen.Id("errors").Dot("WithStack").
					Call(jen.Id(
						fmt.Sprintf(unsupportedStructKeyErrTemplate, mainPkg.ObjectName),
					)),
			),
		))

		f.Commentf("// Transform %s Gorm Column To Struct Key Name", mainPkg.ObjectName)
		f.Func().Id(fmt.Sprintf("Transform%sGormColumnToStructKeyName", mainPkg.ObjectName)).
			Params(jen.Id("gormColumn").String()).Params(jen.String(), jen.Error()).
			Block(jen.Switch(jen.Id("gormColumn")).Block(gormToStructKeyCases...))

		f.Commentf("// Transform %s Struct Key Name To Gorm Column", mainPkg.ObjectName)
		f.Func().Id(fmt.Sprintf("Transform%sStructKeyNameToGormColumn", mainPkg.ObjectName)).
			Params(jen.Id("structKey").String()).Params(jen.String(), jen.Error()).
			Block(jen.Switch(jen.Id("structKey")).Block(structToGormKeyCases...))

		f.Commentf("Transform %s Struct Key Name map To Gorm Column map", mainPkg.ObjectName)
		f.Func().Id(fmt.Sprintf("Transform%sStructKeyNameMapToGormColumnMap", mainPkg.ObjectName)).
			Params(
				jen.Id("input").Map(jen.String()).Any(),
				jen.Id("ignoreUnsupportedError").Bool(),
			).
			Params(jen.Map(jen.String()).Any(), jen.Error()).
			Block(
				jen.Id("m").Op(":=").Map(jen.String()).Any().Values(),
				jen.Line(),
				jen.For(jen.Id("k").Op(",").Id("v").Op(":=").Range().Id("input").Block(
					jen.Id("r").Op(",").Err().Op(":=").Id(
						fmt.Sprintf("Transform%sStructKeyNameToGormColumn", mainPkg.ObjectName),
					).Call(jen.Id("k")),
					jen.If(jen.Err().Op("!=").Nil()).Block(
						jen.If(jen.Id("ignoreUnsupportedError").Op("&&").
							Id("errors").Op(".").Id("Is").Call(
							jen.Err(),
							jen.Id(fmt.Sprintf(unsupportedStructKeyErrTemplate, mainPkg.ObjectName)),
						)).Block(jen.Continue()),
						jen.Return(jen.Nil(), jen.Err()),
					),
					jen.Id("m").Index(jen.Id("r")).Op("=").Id("v"),
				)),
				jen.Line(),
				jen.Return(jen.Id("m"), jen.Nil()),
			)

		f.Commentf("Transform %s Gorm Column map To Struct Key Name map", mainPkg.ObjectName)
		f.Func().Id(fmt.Sprintf("Transform%sGormColumnMapToStructKeyNameMap", mainPkg.ObjectName)).
			Params(
				jen.Id("input").Map(jen.String()).Any(),
				jen.Id("ignoreUnsupportedError").Bool(),
			).
			Params(jen.Map(jen.String()).Any(), jen.Error()).
			Block(
				jen.Id("m").Op(":=").Map(jen.String()).Any().Values(),
				jen.Line(),
				jen.For(jen.Id("k").Op(",").Id("v").Op(":=").Range().Id("input").Block(
					jen.Id("r").Op(",").Err().Op(":=").Id(
						fmt.Sprintf("Transform%sGormColumnToStructKeyName", mainPkg.ObjectName),
					).Call(jen.Id("k")),
					jen.If(jen.Err().Op("!=").Nil()).Block(
						jen.If(jen.Id("ignoreUnsupportedError").Op("&&").
							Id("errors").Op(".").Id("Is").Call(
							jen.Err(),
							jen.Id(fmt.Sprintf(unsupportedGormColumnErrTemplate, mainPkg.ObjectName)),
						)).Block(jen.Continue()),
						jen.Return(jen.Nil(), jen.Err()),
					),
					jen.Id("m").Index(jen.Id("r")).Op("=").Id("v"),
				)),
				jen.Line(),
				jen.Return(jen.Id("m"), jen.Nil()),
			)
	}

	if !disableJSON && !disableStructKeyName {
		jsonToStructKeyCases := []jen.Code{}
		structToJsonKeyCases := []jen.Code{}

		for k := range mainPkg.GormMap {
			jsonToStructKeyCases = append(jsonToStructKeyCases, jen.
				Case(jen.Id(mainPkg.ObjectName+k+jsonKeyNameSuffix)).
				Block(
					jen.Return(
						jen.Id(mainPkg.ObjectName+k+structKeyNameSuffix),
						jen.Nil(),
					),
				),
			)
		}
		for k := range mainPkg.JSONMap {
			structToJsonKeyCases = append(structToJsonKeyCases, jen.
				Case(jen.Id(mainPkg.ObjectName+k+structKeyNameSuffix)).
				Block(
					jen.Return(
						jen.Id(mainPkg.ObjectName+k+structKeyNameSuffix),
						jen.Nil(),
					),
				),
			)
		}

		jsonToStructKeyCases = append(jsonToStructKeyCases, jen.Default().Block(
			jen.Return(
				jen.Lit(""),
				jen.Id("errors").Dot("WithStack").
					Call(jen.Id(
						fmt.Sprintf(unsupportedJSONKeyErrTemplate, mainPkg.ObjectName),
					)),
			),
		))

		structToJsonKeyCases = append(structToJsonKeyCases, jen.Default().Block(
			jen.Return(
				jen.Lit(""),
				jen.Id("errors").Dot("WithStack").
					Call(jen.Id(
						fmt.Sprintf(unsupportedStructKeyErrTemplate, mainPkg.ObjectName),
					)),
			),
		))

		f.Commentf("// Transform %s JSON Key To Struct Key Name", mainPkg.ObjectName)
		f.Func().Id(fmt.Sprintf("Transform%sJSONKeyToStructKeyName", mainPkg.ObjectName)).
			Params(jen.Id("jsonKey").String()).Params(jen.String(), jen.Error()).
			Block(jen.Switch(jen.Id("jsonKey")).Block(jsonToStructKeyCases...))

		f.Commentf("// Transform %s Struct Key Name To JSON Key", mainPkg.ObjectName)
		f.Func().Id(fmt.Sprintf("Transform%sStructKeyNameToJSONKey", mainPkg.ObjectName)).
			Params(jen.Id("structKey").String()).Params(jen.String(), jen.Error()).
			Block(jen.Switch(jen.Id("structKey")).Block(structToJsonKeyCases...))

		f.Commentf("Transform %s Struct Key Name map To JSON Key map", mainPkg.ObjectName)
		f.Func().Id(fmt.Sprintf("Transform%sStructKeyNameMapToJSONKeyMap", mainPkg.ObjectName)).
			Params(
				jen.Id("input").Map(jen.String()).Any(),
				jen.Id("ignoreUnsupportedError").Bool(),
			).
			Params(jen.Map(jen.String()).Any(), jen.Error()).
			Block(
				jen.Id("m").Op(":=").Map(jen.String()).Any().Values(),
				jen.Line(),
				jen.For(jen.Id("k").Op(",").Id("v").Op(":=").Range().Id("input").Block(
					jen.Id("r").Op(",").Err().Op(":=").Id(
						fmt.Sprintf("Transform%sStructKeyNameToJSONKey", mainPkg.ObjectName),
					).Call(jen.Id("k")),
					jen.If(jen.Err().Op("!=").Nil()).Block(
						jen.If(jen.Id("ignoreUnsupportedError").Op("&&").
							Id("errors").Op(".").Id("Is").Call(
							jen.Err(),
							jen.Id(fmt.Sprintf(unsupportedStructKeyErrTemplate, mainPkg.ObjectName)),
						)).Block(jen.Continue()),
						jen.Return(jen.Nil(), jen.Err()),
					),
					jen.Id("m").Index(jen.Id("r")).Op("=").Id("v"),
				)),
				jen.Line(),
				jen.Return(jen.Id("m"), jen.Nil()),
			)

		f.Commentf("Transform %s JSON Key map To Struct Key Name map", mainPkg.ObjectName)
		f.Func().Id(fmt.Sprintf("Transform%sJSONKeyMapToStructKeyNameMap", mainPkg.ObjectName)).
			Params(
				jen.Id("input").Map(jen.String()).Any(),
				jen.Id("ignoreUnsupportedError").Bool(),
			).
			Params(jen.Map(jen.String()).Any(), jen.Error()).
			Block(
				jen.Id("m").Op(":=").Map(jen.String()).Any().Values(),
				jen.Line(),
				jen.For(jen.Id("k").Op(",").Id("v").Op(":=").Range().Id("input").Block(
					jen.Id("r").Op(",").Err().Op(":=").Id(
						fmt.Sprintf("Transform%sJSONKeyToStructKeyName", mainPkg.ObjectName),
					).Call(jen.Id("k")),
					jen.If(jen.Err().Op("!=").Nil()).Block(
						jen.If(jen.Id("ignoreUnsupportedError").Op("&&").
							Id("errors").Op(".").Id("Is").Call(
							jen.Err(),
							jen.Id(fmt.Sprintf(unsupportedJSONKeyErrTemplate, mainPkg.ObjectName)),
						)).Block(jen.Continue()),
						jen.Return(jen.Nil(), jen.Err()),
					),
					jen.Id("m").Index(jen.Id("r")).Op("=").Id("v"),
				)),
				jen.Line(),
				jen.Return(jen.Id("m"), jen.Nil()),
			)

	}
}
