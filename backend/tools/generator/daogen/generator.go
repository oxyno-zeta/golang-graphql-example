package main

import (
	"os"
	"path"
	"strconv"
	"strings"

	"emperror.dev/errors"
	"github.com/dave/jennifer/jen"
)

func generate(cfg *Config) error {
	for _, v := range cfg.Daos {
		// Create directory
		err := os.MkdirAll(v.Path, os.ModePerm)
		// Check error
		if err != nil {
			return errors.WithStack(err)
		}

		// Create new file
		f := jen.NewFile(v.PackageName)

		// A comment to mark the file as generated
		f.PackageComment("Code generated by daogen, DO NOT EDIT.")

		addImports(f, v.Models)

		f.Line()
		f.Comment("/* Interface */")
		f.Line()

		generateInterface(f, v, cfg.NeededPackages)

		f.Line()
		f.Comment("/* New */")
		f.Line()

		f.Func().Id("New" + getInterfaceName(v)).Params(
			jen.Id("db").Qual(cfg.NeededPackages.DB, "DB"),
		).Id(getInterfaceName(v)).Block(
			jen.Return(
				jen.Op("&").Id(getDaoStructureName(v)).Values(jen.Dict{
					jen.Id("db"): jen.Id("db"),
				}),
			),
		)

		f.Line()
		f.Comment("/* Structure */")
		f.Line()

		f.Type().Id(getDaoStructureName(v)).Struct(
			jen.Id("db").Qual(cfg.NeededPackages.DB, "DB"),
		)

		f.Line()
		f.Comment("/* Functions */")
		f.Line()

		generateStructureMethods(f, v, cfg.NeededPackages)

		// Generate path
		p := path.Join(v.Path, strings.ToLower(getInterfaceName(v))+"_generated.go")

		// Save
		err = f.Save(p)
		// Check error
		if err != nil {
			return errors.WithStack(err)
		}
	}

	// Default
	return nil
}

func addImports(f *jen.File, list []*DaoModelCfg) {
	f.ImportName("context", "context")

	// Cache imports to avoid duplicates
	cache := map[string]string{}

	for i, m := range list {
		// Get from cache
		_, found := cache[m.Package]

		// If not found
		if !found {
			// Alias
			f.ImportAlias(m.Package, "models"+strconv.Itoa(i))
			// Save in cache
			cache[m.Package] = ""
		}
	}
}

func generateStructureMethods(f *jen.File, v *DaoCfg, neededPackages *NeededPackagesCfg) {
	for _, m := range v.Models {
		f.Line().Commentf("Starting methods for %s structure", m.StructureName).Line()

		if m.DisabledMethods == nil || !m.DisabledMethods.FindByID {
			f.Func().Params(jen.Id("d").Op("*").Id(getDaoStructureName(v))).
				Id("Find" + m.StructureName + "ByID").
				Add(findByIdParamsAndReturns(m, neededPackages)).Block(jen.Return(
				jen.Qual(neededPackages.Helpers, "FindByID").Params(
					jen.Id("ctx"),
					jen.Op("&").Qual(m.Package, m.StructureName).Values(),
					jen.Id("d.db"),
					jen.Id("id"),
					jen.Id("projection"),
					jen.Id("opts").Op("..."),
				),
			)).Line()
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.FindOne {
			f.Func().Params(jen.Id("d").Op("*").Id(getDaoStructureName(v))).
				Id("FindOne" + m.StructureName).
				Add(findOneParamsAndReturns(m,neededPackages)).Block(jen.Return(
				jen.Qual(neededPackages.Helpers, "FindOne").Params(
					jen.Id("ctx"),
					jen.Op("&").Qual(m.Package, m.StructureName).Values(),
					jen.Id("d.db"),
					jen.Id("sorts"),
					jen.Id("filter"),
					jen.Id("projection"),
					jen.Id("opts").Op("..."),
				),
			)).Line()
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.FindWithPagination {
			f.Func().Params(jen.Id("d").Op("*").Id(getDaoStructureName(v))).
				Id("Find" + m.StructureName + "WithPagination").
				Add(findWithPaginationParamsAndReturns(m, neededPackages)).Block(jen.Return(
				jen.Qual(neededPackages.Helpers, "FindWithPagination").Params(
					jen.Id("ctx"),
					jen.Index().Op("*").Qual(m.Package, m.StructureName).Values(),
					jen.Id("d.db"),
					jen.Id("page"),
					jen.Id("sorts"),
					jen.Id("filter"),
					jen.Id("projection"),
					jen.Id("opts").Op("..."),
				),
			)).Line()
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.FindPaginated {
			f.Func().Params(jen.Id("d").Op("*").Id(getDaoStructureName(v))).
				Id("Find" + m.StructureName + "Paginated").
				Add(findAllPaginatedParamsAndReturns(m, neededPackages)).Block(jen.Return(
				jen.Qual(neededPackages.Helpers, "GetAllPaginated").Params(
					jen.Id("ctx"),
					jen.Index().Op("*").Qual(m.Package, m.StructureName).Values(),
					jen.Id("d.db"),
					jen.Id("page"),
					jen.Id("sorts"),
					jen.Id("filter"),
					jen.Id("projection"),
					jen.Id("opts").Op("..."),
				),
			)).Line()
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.FindAll {
			f.Func().Params(jen.Id("d").Op("*").Id(getDaoStructureName(v))).
				Id("FindAll" + m.StructureName).
				Add(findAllParamsAndReturns(m, neededPackages)).Block(jen.Return(
				jen.Qual(neededPackages.Helpers, "Find").Params(
					jen.Id("ctx"),
					jen.Index().Op("*").Qual(m.Package, m.StructureName).Values(),
					jen.Id("d.db"),
					jen.Id("sorts"),
					jen.Id("filter"),
					jen.Id("projection"),
					jen.Id("opts").Op("..."),
				),
			)).Line()
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.CountPaginated {
			f.Func().Params(jen.Id("d").Op("*").Id(getDaoStructureName(v))).
				Id("Count" + m.StructureName + "Paginated").
				Add(countPaginatedParamsAndReturns(m, neededPackages)).Block(jen.Return(
				jen.Qual(neededPackages.Helpers, "CountPaginated").Params(
					jen.Id("ctx"),
					jen.Id("d.db"),
					jen.Op("&").Qual(m.Package, m.StructureName).Values(),
					jen.Id("page"),
					jen.Id("filter"),
					jen.Id("opts").Op("..."),
				),
			)).Line()
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.Count {
			f.Func().Params(jen.Id("d").Op("*").Id(getDaoStructureName(v))).
				Id("Count" + m.StructureName).
				Add(countParamsAndReturns(m, neededPackages)).Block(jen.Return(
				jen.Qual(neededPackages.Helpers, "Count").Params(
					jen.Id("ctx"),
					jen.Id("d.db"),
					jen.Op("&").Qual(m.Package, m.StructureName).Values(),
					jen.Id("filter"),
					jen.Id("opts").Op("..."),
				),
			)).Line()
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.CreateOrUpdate {
			f.Func().Params(jen.Id("d").Op("*").Id(getDaoStructureName(v))).
				Id("CreateOrUpdate" + m.StructureName).
				Add(createOrUpdateParamsAndReturns(m, neededPackages)).Block(jen.Return(
				jen.Qual(neededPackages.Helpers, "CreateOrUpdate").Params(
					jen.Id("ctx"),
					jen.Id("input"),
					jen.Id("d.db"),
					jen.Id("opts").Op("..."),
				),
			)).Line()
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.PermanentDelete {
			f.Func().Params(jen.Id("d").Op("*").Id(getDaoStructureName(v))).
				Id("PermanentDelete" + m.StructureName).
				Add(permanentDeleteParamsAndReturns(m, neededPackages)).Block(jen.Return(
				jen.Qual(neededPackages.Helpers, "PermanentDelete").Params(
					jen.Id("ctx"),
					jen.Id("input"),
					jen.Id("d.db"),
					jen.Id("opts").Op("..."),
				),
			)).Line()
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.PermanentDeleteByID {
			f.Func().Params(jen.Id("d").Op("*").Id(getDaoStructureName(v))).
				Id("PermanentDelete"+m.StructureName+"ByID").
				Add(permanentDeleteByIDParamsAndReturns(m, neededPackages)).Block(
				// This is make list this to avoid any choice between Base and BaseWithoutIndexes structures
				jen.Id("input").Op(":=").Op("&").Qual(m.Package, m.StructureName).Values(),
				jen.Id("input").Op(".").Id("ID").Op("=").Id("id"),
				jen.Line(),
				jen.Return(
					jen.Qual(neededPackages.Helpers, "PermanentDelete").Params(
						jen.Id("ctx"),
						jen.Id("input"),
						jen.Id("d.db"),
					jen.Id("opts").Op("..."),
					),
				),
			).Line()
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.PermanentDeleteFiltered {
			f.Func().Params(jen.Id("d").Op("*").Id(getDaoStructureName(v))).
				Id("PermanentDelete" + m.StructureName + "Filtered").
				Add(permanentDeleteFilteredParamsAndReturns(m, neededPackages)).Block(jen.Return(
				jen.Qual(neededPackages.Helpers, "PermanentDeleteFiltered").Params(
					jen.Id("ctx"),
					jen.Op("&").Qual(m.Package, m.StructureName).Values(),
					jen.Id("filter"),
					jen.Id("d.db"),
					jen.Id("opts").Op("..."),
				),
			)).Line()
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.PatchUpdate {
			f.Func().Params(jen.Id("d").Op("*").Id(getDaoStructureName(v))).
				Id("PatchUpdate" + m.StructureName).
				Add(patchUpdateParamsAndReturns(m, neededPackages)).Block(jen.Return(
				jen.Qual(neededPackages.Helpers, "PatchUpdate").Params(
					jen.Id("ctx"),
					jen.Id("input"),
					jen.Id("patch"),
					jen.Id("d.db"),
					jen.Id("opts").Op("..."),
				),
			)).Line()
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.PatchUpdateByID {
			f.Func().Params(jen.Id("d").Op("*").Id(getDaoStructureName(v))).
				Id("PatchUpdate"+m.StructureName+"ByID").
				Add(patchUpdateByIDParamsAndReturns(m, neededPackages)).Block(
				// This is make list this to avoid any choice between Base and BaseWithoutIndexes structures
				jen.Id("input").Op(":=").Op("&").Qual(m.Package, m.StructureName).Values(),
				jen.Id("input").Op(".").Id("ID").Op("=").Id("id"),
				jen.Line(),
				jen.Return(
					jen.Qual(neededPackages.Helpers, "PatchUpdate").Params(
						jen.Id("ctx"),
						jen.Id("input"),
						jen.Id("patch"),
						jen.Id("d.db"),
					jen.Id("opts").Op("..."),
					),
				),
			).Line()
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.PatchUpdateFiltered {
			f.Func().Params(jen.Id("d").Op("*").Id(getDaoStructureName(v))).
				Id("PatchUpdate" + m.StructureName + "Filtered").
				Add(patchUpdateFilteredParamsAndReturns(m, neededPackages)).Block(jen.Return(
				jen.Qual(neededPackages.Helpers, "PatchUpdateAllFiltered").Params(
					jen.Id("ctx"),
					jen.Op("&").Qual(m.Package, m.StructureName).Values(),
					jen.Id("patch"),
					jen.Id("filter"),
					jen.Id("d.db"),
					jen.Id("opts").Op("..."),
				),
			)).Line()
		}

		f.Line().Commentf("Ending methods for %s structure", m.StructureName).Line()
	}
}

func generateInterface(f *jen.File, v *DaoCfg, neededPackages *NeededPackagesCfg) {
	list := []jen.Code{}

	// Loop
	for _, m := range v.Models {
		res := []jen.Code{}

		if m.DisabledMethods == nil || !m.DisabledMethods.FindByID {
			res = append(res, jen.Id("Find"+m.StructureName+"ByID").Add(findByIdParamsAndReturns(m, neededPackages)))
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.FindOne {
			res = append(res, jen.Id("FindOne"+m.StructureName).Add(findOneParamsAndReturns(m, neededPackages)))
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.FindWithPagination {
			res = append(res, jen.Id("Find"+m.StructureName+"WithPagination").Add(findWithPaginationParamsAndReturns(m, neededPackages)))
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.FindPaginated {
			res = append(res, jen.Id("Find"+m.StructureName+"Paginated").Add(findAllPaginatedParamsAndReturns(m, neededPackages)))
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.FindAll {
			res = append(res, jen.Id("FindAll"+m.StructureName).Add(findAllParamsAndReturns(m, neededPackages)))
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.CountPaginated {
			res = append(res, jen.Id("Count"+m.StructureName+"Paginated").Add(countPaginatedParamsAndReturns(m, neededPackages)))
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.Count {
			res = append(res, jen.Id("Count"+m.StructureName).Add(countParamsAndReturns(m, neededPackages)))
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.CreateOrUpdate {
			res = append(res, jen.Id("CreateOrUpdate"+m.StructureName).Add(createOrUpdateParamsAndReturns(m, neededPackages)))
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.CreateOrUpdate {
			res = append(res, jen.Id("PermanentDelete"+m.StructureName).Add(permanentDeleteParamsAndReturns(m, neededPackages)))
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.PatchUpdateByID {
			res = append(res, jen.Id("PermanentDelete"+m.StructureName+"ByID").Add(permanentDeleteByIDParamsAndReturns(m, neededPackages)))
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.PatchUpdateFiltered {
			res = append(res, jen.Id("PermanentDelete"+m.StructureName+"Filtered").Add(permanentDeleteFilteredParamsAndReturns(m, neededPackages)))
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.PatchUpdate {
			res = append(res, jen.Id("PatchUpdate"+m.StructureName).Add(patchUpdateParamsAndReturns(m, neededPackages)))
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.PatchUpdateByID {
			res = append(res, jen.Id("PatchUpdate"+m.StructureName+"ByID").Add(patchUpdateByIDParamsAndReturns(m, neededPackages)))
		}

		if m.DisabledMethods == nil || !m.DisabledMethods.PatchUpdateFiltered {
			res = append(res, jen.Id("PatchUpdate"+m.StructureName+"Filtered").Add(patchUpdateFilteredParamsAndReturns(m, neededPackages)))
		}

		if len(res) != 0 {
			f.Commentf("Dao for structure %s", m.StructureName)
			f.Type().Id(getStructureInterfaceName(m.StructureName, v)).Interface(
				res...,
			)
			f.Line()

			list = append(list, jen.Id(getStructureInterfaceName(m.StructureName, v)))
		}
	}

	f.Comment("General Dao")
	f.Type().Id(getInterfaceName(v)).Interface(
		list...,
	)
}

func patchUpdateFilteredParamsAndReturns(m *DaoModelCfg, neededPackages *NeededPackagesCfg) jen.Code {
	return jen.Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("filter").Op("*").Qual(m.Package, getFilterStructureName(m)),
		jen.Id("patch").Map(jen.String()).Any(),
		jen.Id("opts").Op("...").Qual(neededPackages.Helpers, "GormOpt"),
	).Parens(jen.Error())
}

func patchUpdateParamsAndReturns(m *DaoModelCfg, neededPackages *NeededPackagesCfg) jen.Code {
	return jen.Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("input").Op("*").Qual(m.Package, m.StructureName),
		jen.Id("patch").Map(jen.String()).Any(),
		jen.Id("opts").Op("...").Qual(neededPackages.Helpers, "GormOpt"),
	).Parens(jen.List(
		jen.Op("*").Qual(m.Package, m.StructureName),
		jen.Error(),
	))
}

func patchUpdateByIDParamsAndReturns(m *DaoModelCfg, neededPackages *NeededPackagesCfg) jen.Code {
	return jen.Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("id").String(),
		jen.Id("patch").Map(jen.String()).Any(),
		jen.Id("opts").Op("...").Qual(neededPackages.Helpers, "GormOpt"),
	).Parens(jen.List(
		jen.Op("*").Qual(m.Package, m.StructureName),
		jen.Error(),
	))
}

func createOrUpdateParamsAndReturns(m *DaoModelCfg, neededPackages *NeededPackagesCfg) jen.Code {
	return jen.Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("input").Op("*").Qual(m.Package, m.StructureName),
		jen.Id("opts").Op("...").Qual(neededPackages.Helpers, "GormOpt"),
	).Parens(jen.List(
		jen.Op("*").Qual(m.Package, m.StructureName),
		jen.Error(),
	))
}

func permanentDeleteParamsAndReturns(m *DaoModelCfg, neededPackages *NeededPackagesCfg) jen.Code {
	return jen.Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("input").Op("*").Qual(m.Package, m.StructureName),
		jen.Id("opts").Op("...").Qual(neededPackages.Helpers, "GormOpt"),
	).Parens(jen.List(
		jen.Op("*").Qual(m.Package, m.StructureName),
		jen.Error(),
	))
}

func permanentDeleteByIDParamsAndReturns(m *DaoModelCfg, neededPackages *NeededPackagesCfg) jen.Code {
	return jen.Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("id").String(),
		jen.Id("opts").Op("...").Qual(neededPackages.Helpers, "GormOpt"),
	).Parens(jen.List(
		jen.Op("*").Qual(m.Package, m.StructureName),
		jen.Error(),
	))
}

func permanentDeleteFilteredParamsAndReturns(m *DaoModelCfg, neededPackages *NeededPackagesCfg) jen.Code {
	return jen.Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("filter").Op("*").Qual(m.Package, getFilterStructureName(m)),
		jen.Id("opts").Op("...").Qual(neededPackages.Helpers, "GormOpt"),
	).Error()
}

func findAllPaginatedParamsAndReturns(m *DaoModelCfg, neededPackages *NeededPackagesCfg) jen.Code {
	return jen.Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("page").Op("*").Qual(neededPackages.Pagination, "PageInput"),
		jen.Id("sorts").Index().Op("*").Qual(m.Package, getSortOrderStructureName(m)),
		jen.Id("filter").Op("*").Qual(m.Package, getFilterStructureName(m)),
		jen.Id("projection").Op("*").Qual(m.Package, getProjectionStructureName(m)),
		jen.Id("opts").Op("...").Qual(neededPackages.DB, "TransactionOption"),
	).Parens(jen.List(
		jen.Index().Op("*").Qual(m.Package, m.StructureName),
		jen.Op("*").Qual(neededPackages.Pagination, "PageOutput"),
		jen.Error(),
	))
}

func findWithPaginationParamsAndReturns(m *DaoModelCfg, neededPackages *NeededPackagesCfg) jen.Code {
	return jen.Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("page").Op("*").Qual(neededPackages.Pagination, "PageInput"),
		jen.Id("sorts").Index().Op("*").Qual(m.Package, getSortOrderStructureName(m)),
		jen.Id("filter").Op("*").Qual(m.Package, getFilterStructureName(m)),
		jen.Id("projection").Op("*").Qual(m.Package, getProjectionStructureName(m)),
		jen.Id("opts").Op("...").Qual(neededPackages.Helpers, "GormOpt"),
	).Parens(jen.List(
		jen.Index().Op("*").Qual(m.Package, m.StructureName),
		jen.Error(),
	))
}

func countPaginatedParamsAndReturns(m *DaoModelCfg, neededPackages *NeededPackagesCfg) jen.Code {
	return jen.Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("page").Op("*").Qual(neededPackages.Pagination, "PageInput"),
		jen.Id("filter").Op("*").Qual(m.Package, getFilterStructureName(m)),
		jen.Id("opts").Op("...").Qual(neededPackages.Helpers, "GormOpt"),
	).Parens(jen.List(
		jen.Int64(),
		jen.Error(),
	))
}

func countParamsAndReturns(m *DaoModelCfg, neededPackages *NeededPackagesCfg) jen.Code {
	return jen.Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("filter").Op("*").Qual(m.Package, getFilterStructureName(m)),
		jen.Id("opts").Op("...").Qual(neededPackages.Helpers, "GormOpt"),
	).Parens(jen.List(
		jen.Int64(),
		jen.Error(),
	))
}

func findByIdParamsAndReturns(m *DaoModelCfg, neededPackages *NeededPackagesCfg) jen.Code {
	return jen.Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("id").String(),
		jen.Id("projection").Op("*").Qual(m.Package, getProjectionStructureName(m)),
		jen.Id("opts").Op("...").Qual(neededPackages.Helpers, "GormOpt"),
	).Parens(jen.List(jen.Op("*").Qual(m.Package, m.StructureName), jen.Error()))
}

func findOneParamsAndReturns(m *DaoModelCfg, neededPackages *NeededPackagesCfg) jen.Code {
	return jen.Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("sorts").Index().Op("*").Qual(m.Package, getSortOrderStructureName(m)),
		jen.Id("filter").Op("*").Qual(m.Package, getFilterStructureName(m)),
		jen.Id("projection").Op("*").Qual(m.Package, getProjectionStructureName(m)),
		jen.Id("opts").Op("...").Qual(neededPackages.Helpers, "GormOpt"),
	).Parens(jen.List(jen.Op("*").Qual(m.Package, m.StructureName), jen.Error()))
}

func findAllParamsAndReturns(m *DaoModelCfg, neededPackages *NeededPackagesCfg) jen.Code {
	return jen.Params(
		jen.Id("ctx").Qual("context", "Context"),
		jen.Id("sorts").Index().Op("*").Qual(m.Package, getSortOrderStructureName(m)),
		jen.Id("filter").Op("*").Qual(m.Package, getFilterStructureName(m)),
		jen.Id("projection").Op("*").Qual(m.Package, getProjectionStructureName(m)),
		jen.Id("opts").Op("...").Qual(neededPackages.Helpers, "GormOpt"),
	).Parens(jen.List(jen.Index().Op("*").Qual(m.Package, m.StructureName), jen.Error()))
}

func getDaoStructureName(input *DaoCfg) string {
	return strings.ToLower(getInterfaceName(input))
}

func getStructureInterfaceName(structureName string, input *DaoCfg) string {
	return structureName + "Structure" + getInterfaceName(input)
}

func getInterfaceName(input *DaoCfg) string {
	if input.InterfaceName != "" {
		return input.InterfaceName
	}

	return "DaoGenerated"
}

func getProjectionStructureName(input *DaoModelCfg) string {
	if input.ProjectionStructureName != "" {
		return input.ProjectionStructureName
	}

	return input.StructureName + "Projection"
}

func getFilterStructureName(input *DaoModelCfg) string {
	if input.FilterStructureName != "" {
		return input.FilterStructureName
	}

	return input.StructureName + "Filter"
}

func getSortOrderStructureName(input *DaoModelCfg) string {
	if input.SortOrderStructureName != "" {
		return input.SortOrderStructureName
	}

	return input.StructureName + "SortOrder"
}
